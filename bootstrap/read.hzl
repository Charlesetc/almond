
# Read

struct TSymbol {
  symbol
}

define TSymbol {
  t = new TSymbol
  t.symbol = List
  t
}

struct TEOF {
  list
}
struct TItemBreak {
  list
}

define TEOF { l
  a = new TEOF
  a.list = l
  a
}

define TItemBreak { l
  a = new TItemBreak
  a.list = l
  a
}

define HZL/builtin-read do read-table stream 

  # if (table.get stream.peek) is nil
  # or  stream.peak is nil
  first_condition = (read-table.get stream.peek) == nil)
  condition = or (not first_condition) (stream.peek == nil)
  if condition {
    return TSymbol
  }
  current = stream.pop
  token = HZL/builtin-read read-table stream
  # This token is only a TSymbol
  token.symbol.push current
  return token
end

define HZL/read do read-table stream
  if (stream.peek == nil) {
    return (new TEOF)
  }
  reader = read-table.get stream.peek
  if (not reader) {
    reader = lambda do read-table stream
      HZL/builtin-read read-table stream
    end
  }
  call reader read-table stream
end

define HZL/read-expression do read-table stream
  a = HZL/read read-table stream

  if (kind a == "TEOF") {
    return (TEOF List)
  }
  if (kind a == "TItemBreak") {
    return (TItemBreak List)
  }


  list = HZL/read-expression read-table stream

  # if a != nil
  condition = a == nil
  if (not condition) {
    list.list.push a
  }
  list
end

define HZL/start do read-table stream
  expr = HZL/read-expression read-table stream
  if (kind expr == "TItemBreak") {
    items = HZL/start read-table stream
    items.push expr
    return items
  }
  assert (kind expr == "TEOF")
  return (List expr)
end

read-nothing = lambda do _ stream
  stream.pop
  nil
end

read-newline = lambda do _ stream
  stream.pop
  new TItemBreak
end

read-table = Table
read-table.add (char ' ') read-nothing
read-table.add (char '\n') read-newline

items = HZL/start read-table (List/from_a 'test this\nand\nthat')

items.each do item
  puts "Item:"
  item.list.each do tree
    tree.symbol.print
  end
end
