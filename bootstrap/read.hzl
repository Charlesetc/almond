
# Read

# Any identifier
struct TSymbol {
  symbol
}

# Something that should be parsed as an operator
struct TOperator {
  char
}

struct TAccumulator {
  token_type
  list
}

define TAccumulator.each do {
  block = lambda yield
  self.list.each do i
    call block i
  end
}

define TAccumulator.length do {
  self.list.length
}

define TAccumulator.pop do {
  self.list.pop
}

# Used internally when parsing.
# Should not be in the final syntax tree.
struct TToken {
  char
}

# Generic Accumulator
define TList { l
  TAccumulator "TList" l
}

define TSymbol {
  t = new TSymbol
  # This is an ok occurance of List
  t.symbol = List
  t
}

define TEOF { l
  TAccumulator "TEOF" l
}

define TItemBreak { l
  TAccumulator "TItemBreak" l
}

define TAccumulator { token_type l
  a = new TAccumulator
  a.token_type = token_type
  a.list = l
  a
}

define TToken { c
  a = new TToken
  a.char = c
  a
}

define TOperator { c
  a = new TOperator
  a.char = c
  a
}

# All possible ast types

define TToken.token_type {
  "TToken"
}

define TSymbol.token_type {
  "TSymbol"
}

define nil.token_type {
  "TNil"
}

define TOperator.token_type {
  "TOperator"
}


define HZL/builtin-read do read-table stream 
  # if (table.get stream.peek) is nil
  # or  stream.peak is nil
  first_condition = (read-table.get stream.peek) == nil)
  condition = or (not first_condition) (stream.peek == nil)
  if condition {
    return TSymbol
  }
  current = stream.shift
  token = HZL/builtin-read read-table stream
  # This token is only a TSymbol
  token.symbol.unshift current
  return token
end

define HZL/read do read-table stream
  if (stream.peek == nil) {
    return (TEOF List)
  }
  reader = read-table.get stream.peek
  if (not reader) {
    reader = lambda do read-table stream
      HZL/builtin-read read-table stream
    end
  }
  call reader read-table stream
end

# Read until we hit the end of a line, file, or block
define HZL/read-expression do read-table stream
  a = HZL/read read-table stream

  if (a.token_type == "TEOF") {
    return a
  }
  if (a.token_type == "TItemBreak") {
    return a
  }

  list = HZL/read-expression read-table stream

  # if a != nil
  condition = a == nil
  if (not condition) {
    list.list.unshift a
  }
  list
end

define HZL/start do read-table stream
  expr = HZL/read-expression read-table stream
  if (expr.token_type == "TItemBreak") {
    items = HZL/start read-table stream
    items.list.unshift expr
    return items
  }
  assert (expr.token_type == "TEOF")
  return (TList (List expr))
end

define HZL/read-open-paren do read-table stream
  a = HZL/read read-table stream

  if (a.token_type == "TEOF") {
    raise # EOF in a paren? IMPOSSIBLE
  }
  if (a.token_type == "TItemBreak") {
    # Ignore Item breaks in parentheses
    return (HZL/read-open-paren read-table stream)
  }
  if (kind a == "TToken") {
    condition = a.char == (char ')')
    if condition {
      return (TList List)
    }
  }

  tlist = HZL/read-open-paren read-table stream

  condition = a == nil
  if (not condition) {
    tlist.list.unshift a
  }
  tlist
end

define default-table do

  read-nothing = lambda do _ stream
    stream.shift
    nil
  end

  read-newline = lambda do _ stream
    stream.shift
    (TItemBreak List)
  end

  operator-function = lambda do _ stream
    a = stream.shift
    TOperator a
  end

  read-close-paren = lambda do _ stream
    stream.shift
    TToken (char ')')
  end

  read-open-paren = lambda do read-table stream
    stream.shift
    HZL/read-open-paren read-table stream
  end

  read-table = Table
  read-table.add (char ' ') read-nothing
  read-table.add (char '\n') read-newline
  read-table.add (char ':') read-newline
  read-close-paren = read-close-paren
  read-table.add (char '(') read-open-paren
  read-table.add (char ')') read-close-paren

  operators = [(char '*') (char '+')]

  operators.each do operator
    read-table.add operator operator-function
  end

  read-table
end

define print-ast { ast
  if (kind ast == "TAccumulator") {
    print '['
    print ast.token_type
    print ']'
    puts "("
    ast.list.each do a
      print-ast a
    end
    puts ")"
    return nil
  }
  if (kind ast == "TOperator") {
    print "Op("
    print ast.char
    puts ")"
    return nil
  }
  if (kind ast == "List") {
    puts "[list]("
    ast.each do a
      print-ast a
    end
    puts ")"
    return nil
  }
  ast.symbol.print
}
