
# Hazelnut Standard Library

binding (*) int do x int y int
"a := *x * *y"
"&a"
end

binding (-) int do x int y int
"a := *y - *x"
"&a"
end

binding false bool do
  "a := false"
  "&a"
end

binding nil nil do
  ""
  "nil"
end

binding true bool do
  "a := true"
  "&a"
end

binding gets string do
  "
  reader := bufio.NewReader(os.Stdin)
  a, _ := reader.ReadString('\n')
  "
  "&a"
end

define string.length do
  get_string_length(self)
end

binding get_string_length int do x string
"temp := len(*x)"
"&temp"
end

# Very inefficient
define int.times do

  if (self == 0) {
    return nil
  }

  yield

  block = lambda(yield)
  a = (self - 1)
  a.times do
    call block
  end
end

struct list {
  next
  last
  value
}

define list { x
  a = new list
  a.next = nil
  a.last = nil
  a.value = x
  a
}

define list.push { x
  if self.next {
    c = self.next
    c.push x
  } else {
    b = list x
    self.next = b
    b.last = self
    return nil
  }
}

define list.print {
  self.map { x
    print " -> "
    print x
  }
  puts
}

define list.map {

  a = self.value
  yield a

  if self.next {
    block = lambda(yield)
    b = self.next
    b.map do x
      call block x
    end
  }
}

define list.pop {
  if self.next {
    a = self.next
    if a.next {
      return a.pop
    } else {
      val = a.value
      self.next = nil
      a.last = nil
      return val
   }
  }
  # a = self.value
  self.value = nil
  return self
}
